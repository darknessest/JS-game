<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>First Game</title>
    <script src="pixi/pixi.min.js"></script>
    <!--<style>* {padding: 0; margin: 0}</style>-->
</head>
<body>

<script type="text/javascript">

    let type = "WebGL"
    if (!PIXI.utils.isWebGLSupported()) {
        type = "canvas"
    }
    PIXI.utils.sayHello(type)

    let Application = PIXI.Application,
        loader = PIXI.loader,
        resources = PIXI.loader.resources,
        Sprite = PIXI.Sprite;

    let app = new PIXI.Application({
        width: 512,
        height: 512,
        antialias: true,    // default: false
        transparent: false, // default: false
        resolution: 1
    })
    // var scale = scaleToWindow(renderer.view, "white");
    // pointer.x /= scale;
    // pointer.y /= scale;
    // window.addEventListener("resize", function (event) {
    //     scaleToWindow(anyelementElement);
    // })
    // app.renderer.backgroundColor = 0x1e6f1d00;
    app.renderer.view.style.position = "absolute";
    app.renderer.view.style.display = "block";
    app.renderer.autoResize = true;
    app.renderer.resize(window.innerWidth, 720/*window.innerHeight*/);
    document.body.appendChild(app.view);

    var newStyle = document.createElement("style");
    var style = "* {padding: 0; margin: 0}";
    newStyle.appendChild(document.createTextNode(style));
    document.head.appendChild(newStyle);


    PIXI.loader
        .add("hero_img", "resources/hero.png")
        .add("background", "resources/BG.png")
        .on(loadProgressHandler)
        .load(setup);

    function loadProgressHandler(loader, resource) {
        //Display the file `url` currently being loaded
        ////console.log("loading: " + resource.url);

        //Display the percentage of files currently loaded
        console.log("progress: " + loader.progress + "%");

        //If you gave your files names as the first argument
        //of the `add` method, you can access them like this
        //console.log("loading: " + resource.name);
    }


    let hero, state;

    // var enemy = {};

    function setup() {
        console.log("All files loaded");

        let background = new Sprite(PIXI.loader.resources.background.texture);
        app.stage.addChild(background);

        hero = new Sprite(PIXI.loader.resources.hero_img.texture);
        hero.position.set(app.stage.width - hero.width, hero.height / 2);
        hero.interactive = true;
        hero.buttonMode = true;
        hero.anchor.set(0.5);
        hero
            .on('mousedown', onDragStart)
            .on('mouseup', onDragEnd)
            .on('mouseupoutside', onDragEnd)
            .on('mousemove', onDragMove)
            .on('touchstart', onDragStart)
            .on('touchend', onDragEnd)
            .on('touchendoutside', onDragEnd)
            .on('touchmove', onDragMove);

        hero.vx = 0;
        hero.vy = 0;
        hero.scale.set(0.1);
        // hero.scale.x = 0.1;
        // hero.scale.y = 0.1;
        hero.rotation = 3.14159216/2;
        app.stage.addChild(hero);

        var enemy = {};

        for (let i = 0; i < 10; i++) {
            enemy[i] = new Sprite(PIXI.loader.resources.hero_img.texture);
            enemy[i].position.set(randomInt(10, app.stage.width - 300), randomInt(20, app.stage.height - 500));
            enemy[i].scale.x = randomInt(2, 8) / 100;
            enemy[i].scale.y = enemy[i].scale.x;
            app.stage.addChild(enemy[i]);
        }


        let left = keyboard(37),
            up = keyboard(38),
            right = keyboard(39),
            down = keyboard(40);

        left.press = () => {
            hero.vx = -5;
            hero.vy = 0;
        };

        left.release = () => {
            if (!right.isDown && hero.vy === 0) {
                hero.vx = 0;
            }
        };

        //Up
        up.press = () => {
            hero.vy = -5;
            hero.vx = 0;
        };
        up.release = () => {
            if (!down.isDown && hero.vx === 0) {
                hero.vy = 0;
            }
        };

        //Right
        right.press = () => {
            hero.vx = 5;
            hero.vy = 0;
        };
        right.release = () => {
            if (!left.isDown && hero.vy === 0) {
                hero.vx = 0;
            }
        };

        //Down
        down.press = () => {
            hero.vy = 5;
            hero.vx = 0;
        };
        down.release = () => {
            if (!up.isDown && hero.vx === 0) {
                hero.vy = 0;
            }
        };


        state = play;
        //Start the game loop
        app.ticker.add(delta => gameLoop(delta));
    }

    function gameLoop(delta) {

        // for (let i = 0; i < 2; i++) {
        //     let enemy = (new Sprite(PIXI.loader.resources.hero_img.texture));
        //     enemy.position.set(randomInt(10, app.stage.width), randomInt(20, app.stage.height));
        //     enemy.scale.x = randomInt(1, 10) / 100;
        //     enemy.scale.y = enemy.scale.x;
        //     app.stage.addChild(enemy);
        // }

        state(delta);

    }

    function play(delta) {
        hero.y += hero.vy;
        hero.x += hero.vx;
    }

    function end() {
        //All the code that should run at the end of the game
    }

    function onDragStart(event) {
        // store a reference to the data
        // the reason for this is because of multitouch
        // we want to track the movement of this particular touch
        this.data = event.data;
        this.alpha = 0.5;
        this.dragging = true;
    }

    function onDragEnd() {
        this.alpha = 1;
        this.dragging = false;
        // set the interaction data to null
        this.data = null;
    }

    function onDragMove() {
        if (this.dragging) {
            var newPosition = this.data.getLocalPosition(this.parent);
            this.x = newPosition.x;
            this.y = newPosition.y;
        }
    }

    function keyboard(keyCode) {
        let key = {};
        key.code = keyCode;
        key.isDown = false;
        key.isUp = true;
        key.press = undefined;
        key.release = undefined;
        //The `downHandler`
        key.downHandler = event => {
            if (event.keyCode === key.code) {
                if (key.isUp && key.press) key.press();
                key.isDown = true;
                key.isUp = false;
            }
            event.preventDefault();
        };

        //The `upHandler`
        key.upHandler = event => {
            if (event.keyCode === key.code) {
                if (key.isDown && key.release) key.release();
                key.isDown = false;
                key.isUp = true;
            }
            event.preventDefault();
        };

        //Attach event listeners
        window.addEventListener(
            "keydown", key.downHandler.bind(key), false
        );
        window.addEventListener(
            "keyup", key.upHandler.bind(key), false
        );
        return key;
    }

    function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
</script>
</body>
</html>